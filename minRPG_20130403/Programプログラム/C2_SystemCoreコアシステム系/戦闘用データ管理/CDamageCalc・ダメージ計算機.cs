using System;
using System.Collections.Generic;
using System.Text;

namespace PublicDomain
{
    /// <summary>
    /// 戦闘などで使われる、ダメージ計算機です。様々なバリエーションが用意されています。
    /// </summary>
    public class CDamageCalc・ダメージ計算機
    {

        /// <summary>
        /// 物理ダメージを計算して返します。
        /// </summary>
        public static double getFhysicalDamage(double _攻撃力, double _相手の守備力, double _ダメージ倍率＿基本は１, bool _isクリティカル, bool _is会心, bool _is奇跡orまぐれ, double _増減率＿基本は０＿０５)
        {
            return FDamageCalculator.getFhysicalDamage(_攻撃力, _相手の守備力, _ダメージ倍率＿基本は１, _増減率＿基本は０＿０５, _isクリティカル, _is会心, _is奇跡orまぐれ);
        }
        /// <summary>
        /// 物理ダメージを計算して返します。
        /// </summary>
        public static double getFhysicalDamage(double _攻撃力, double _相手の守備力, double _ダメージ倍率＿基本は１, double _e・エスカレーション指数係数＿基本は１＿００から１＿１０位, bool _isクリティカル, bool _is会心, bool _is奇跡orまぐれ, bool _isランダムダメージtrue増減＿false固定, bool _ダメージが少ない時も増減値を変動させるか＿trueはさせる＿falseは固定値になる, double _増減率＿基本は０＿０５, bool _増減確率分布＿trueは正規分布_falseは等確立分布)
        {
            return FDamageCalculator.getFhysicalDamage(_攻撃力, _相手の守備力, _ダメージ倍率＿基本は１, _e・エスカレーション指数係数＿基本は１＿００から１＿１０位, _isクリティカル, _is会心, _is奇跡orまぐれ, _isランダムダメージtrue増減＿false固定, _ダメージが少ない時も増減値を変動させるか＿trueはさせる＿falseは固定値になる, _増減率＿基本は０＿０５, _増減確率分布＿trueは正規分布_falseは等確立分布);
        }
        /// <summary>
        /// 物理ダメージを計算して返します。引数でクリティカルの有無を指定できます。
        /// </summary>
        public static double getFhysicalDamage(bool _isクリティカル無し＿true通常攻撃のみ＿falseだと会心や奇跡まぐれもあり)
        {
            return FDamageCalculator.getFhysicalDamage(_isクリティカル無し＿true通常攻撃のみ＿falseだと会心や奇跡まぐれもあり);
        }
        /// <summary>
        /// 物理ダメージを計算して返します。引数に指定したisクリティカルかどうか…などに従ったクリティカル判定でダメージを計算します。
        /// </summary>
        public static double getFhysicalDamage(bool _isクリティカル, bool _is会心, bool _is奇跡orまぐれ)
        {
            return FDamageCalculator.getFhysicalDamage(_isクリティカル, _is会心, _is奇跡orまぐれ);
        }


        public static int getBattleD1・カスタマイズ可能な物理ダメージ(double _攻撃力, double _相手の守備力, double _ダメージ倍率＿基本は１, bool _isクリティカル, bool _is会心, bool _is奇跡orまぐれ, bool _ダメージが少ない時も増減値を変動させるか＿trueはさせる＿falseは固定値になる, double _増減率＿基本は０＿０５位, bool _増減確率分布＿trueは正規分布_falseは等確率)
        {
            double _ダメージ強化定数 = _ダメージ倍率＿基本は１ * 0.5; // （参考までに、ディスガイアは0.33、ＤＱやＲＰＧツクールは0.5）
            double _ダメージ中間値 = (_攻撃力 - (_相手の守備力 * 0.5)) * _ダメージ強化定数;
            // 増減率は、ひとケタの場合は基本１/８ダメージ、8ダメージ以上は１／３２。　（ＤＱ５を参考。参考までに、ＤＱ９は、1/16）
            double _増減率 = _増減率＿基本は０＿０５位;
            // 最低・最大ダメージは切り捨て
            int _最小ダメージ = (int)(_ダメージ中間値 * (1.0 - _増減率));
            int _最大ダメージ = (int)(_ダメージ中間値 * (1.0 + _増減率));
            // 増減率が多いとバラツキ過ぎるので、ある閾値以上は乱数倍率を下げる
            //  （ＳＦＣ版ドラクエ５を参考。例：ＤＱ５では、最小ダメージが８未満なら増減率は１／８、８以上なら増減値１／３２とする。だから１～７ダメでもちゃんと±1でバラつき、８～３１ダメもひとケタの時と同じ位±1でバラつく。±2以上のバラつきは６４ダメ～）
            if (_最小ダメージ < 0)
            {
                // 最小ダメージがマイナスの時は、0か1（５０％でいいのか？）
                _最小ダメージ = 0;
                _最大ダメージ = 1;
            }
            if (_ダメージが少ない時も増減値を変動させるか＿trueはさせる＿falseは固定値になる == true)
            {
                // ここでは、最大ダメージによって増減率を変更している。
                if (_最大ダメージ <= 1.0 / _増減率)
                {
                    _増減率 = 1 / 8; // １～8ダメージでも±１の変動幅を実現するために、１／８。（ＤＱ５を参考）
                }
                _最小ダメージ = (int)(_ダメージ中間値 * (1.0 - _増減率)); // もう一度計算
                _最大ダメージ = (int)(_ダメージ中間値 * (1.0 + _増減率)); // もう一度計算
            }            
            // 受けるダメージとランダム性
            double _受けるダメージ = _ダメージ中間値;
            if (_増減確率分布＿trueは正規分布_falseは等確率 == false)
            {
                // ダメージが出る確率は1ずつ均等。最小・最大ダメージが、ダメージ中間値より出にくい、ということはない。
                _受けるダメージ = MyTools.getRandomNum(_最小ダメージ, _最大ダメージ);
            }
            else
            {
                // ダメージが出る確率は正規分布に従う。最低・最大ダメージは、ダメージ中間値よりかなり出にくい。
                // 等確率の場合とバランスを取りたい場合、正規分布の場合だけ増減率を増やす（最小・最大ダメージをあげる）…ということも考えて。
                _受けるダメージ = MyTools.getSeikiRandomNum_RealWorldRate(_ダメージ中間値, _最小ダメージ, _最大ダメージ); 
            }
            //_物理ダメージは四捨五入(0.5未満でないと，ダメージが0にならないとする)
            int _int受けるダメージ = (int)(_受けるダメージ + 0.5);

            return _int受けるダメージ;
        }

        public static double getBattle2・ドラクエ風の物理ダメージ(double _攻撃力, double _相手の守備力, bool _is会心無し＿true通常攻撃のみ＿falseだと会心の確率を内部で計算, double _会心率＿原作は０＿０３１２５)
        {
            bool _is会心 = false;
            if (_is会心無し＿true通常攻撃のみ＿falseだと会心の確率を内部で計算 == false)
            {
                // 会心判定
                double _会心率用乱数 = 0.01 * (double)MyTools.getRandomNum(1, 100);
                if (_会心率用乱数 <= _会心率＿原作は０＿０３１２５)
                {
                    _is会心 = true;
                }
            }

            double _ダメージ割り算係数 = 0.5; // （参考までに、ディスガイアは0.33、ＤＱやＲＰＧツクールは0.5）
            double _ダメージ中間値 = (_攻撃力 - (_相手の守備力 * 0.5)) * _ダメージ割り算係数;
            // 会心の一撃（痛恨の一撃）の場合は、防御無視で攻撃力そのままのダメージ
            if (_is会心 == true) _ダメージ中間値 = _攻撃力;
            // 増減率は、ひとケタの場合は基本１/８ダメージ、８ダメージ以上は１／３２。　（ＤＱ５を参考。参考までに、ＤＱ９は、1/16）
            double _増減率 = 1 / 8;
            // 最低・最大ダメージは切り捨て
            int _最小ダメージ = (int)(_ダメージ中間値 * (1.0 - _増減率));
            int _最大ダメージ = (int)(_ダメージ中間値 * (1.0 + _増減率));
            // 増減率が多いとバラツキ過ぎるので、ある閾値以上は乱数倍率を下げる
            //  （ＳＦＣ版ドラクエ５を参考。例：ＤＱ５では、最小ダメージが８未満なら増減率は１／８、８以上なら増減値１／３２とする。だから１～７ダメでもちゃんと±1でバラつき、８～３１ダメもひとケタの時と同じ位±1でバラつく。±2以上のバラつきは６４ダメ～）
            if (_最小ダメージ < 0)
            {
                // 最小ダメージがマイナスの時は、0か1
                _最小ダメージ = 0;
                _最大ダメージ = 1;
            }
            else if (_最小ダメージ >= 1.0 / _増減率)
            {
                _増減率 = _増減率 / 4; // ８ダメージ以上は１／３２。（ＤＱ５を参考）
                _最小ダメージ = (int)(_ダメージ中間値 * (1.0 - _増減率)); // もう一度計算
                _最大ダメージ = (int)(_ダメージ中間値 * (1.0 + _増減率)); // もう一度計算
            }
            // ダメージは1ずつ均等。最低・最大ダメージが、通常ダメージより出にくい、ということはない。
            double _受けるダメージ = MyTools.getRandomNum(_最小ダメージ, _最大ダメージ);
            return _受けるダメージ;
        }




        // 【汎用的なランダムダメージ計算機】■ダメージのランダム性の持たせ方を定義したメソッド: getRandomDamage
        /// <summary>
        /// 【汎用的なランダムダメージ計算機】
        /// ■ダメージのランダム性の持たせ方を定義したメソッドです。
        /// 引数１のダメージ中間値を元に、ランダム性を含んだダメージを計算して返します。
        /// </summary>
        public static double getRandomDamage(double _ダメージ中間値, double _増減率＿基本は０＿０５, bool _ダメージが少ない時も増減値を変動させるか＿trueはさせる＿falseは固定値になる, bool _増減確率分布＿trueは正規分布_falseは等確立分布)
        {
            // 必要はないが、メソッドの引数的に必要なのでとりあえず宣言
            double _最小ダメージ = 0;
            double _最大ダメージ = 0;
            return getRandomDamage(_ダメージ中間値, _増減率＿基本は０＿０５, true, true, out _最小ダメージ, out _最大ダメージ);
        }
        /// <summary>
        /// 【汎用的なランダムダメージ計算機】
        /// ■ダメージのランダム性の持たせ方を定義したメソッドです。
        /// 引数１のダメージ中間値を元に、ランダム性を含んだダメージを計算して返します。
        /// 最大ダメージと最小ダメージも取得可能です。
        /// </summary>
        public static double getRandomDamage(double _ダメージ中間値, double _増減率＿基本は０＿０５, bool _ダメージが少ない時も増減値を変動させるか＿trueはさせる＿falseは固定値になる, bool _増減確率分布＿trueは正規分布_falseは等確立分布, out double _最小ダメージ, out double _最大ダメージ)
        {
            // ダメージの増減率（ランダム性）の設定
            //右のように書くと一行でかけるが、ダメージが小さい時、最小ダメージ＝＝最大ダメージのときもあるので、ランダム性としては微妙。_受けるダメージ = MyTools.getRandomNum((int)(-1 * _ダメージ中間値 * _R), (int)(_ダメージ中間値 * _R));
            // 増減率は、ひとケタの場合は基本１/８ダメージ、8ダメージ以上は１／３２。　（ＤＱ５を参考。参考までに、ＤＱ９は、1/16）
            double _増減率 = _増減率＿基本は０＿０５; // 増減率が0の時も一応対応している
            // 増減率が1.0や-1.0だった場合、この式では0になってしまうので、0.001足しておく
            if (_増減率 == 1.0 || _増減率 == -1.0) _増減率 += 0.001;
            // 最低・最大ダメージは切り捨て
            _最小ダメージ = (long)(_ダメージ中間値 * (1.0 - _増減率));
            _最大ダメージ = (long)(_ダメージ中間値 * (1.0 + _増減率));
            // 最大ダメージがマイナスの時は、ダメージは0か1（５０％）
            if (_最大ダメージ <= 0)
            {
                _ダメージ中間値 = 0;
                _最小ダメージ = 0;
                _最大ダメージ = 1;
            }
            // ダメージが小さい場合、増減率が多いとバラつかなくなるので、ある閾値以下は増減率を下げる
            // （ＳＦＣ版ドラクエ５を参考。例：ＤＱ５では、最小ダメージが８未満なら増減率は１／８、８以上なら増減値１／３２とする。だから１～７ダメでもちゃんと±1でバラつき、８～３１ダメもひとケタの時と同じ位±1でバラつく。±2以上のバラつきは６４ダメ～）
            else if (_ダメージが少ない時も増減値を変動させるか＿trueはさせる＿falseは固定値になる == true)
            {
                // ここでは、最大ダメージによって増減率を変更している。
                if (_増減率 != 0.0 && _最大ダメージ <= 1.0 / _増減率)
                {
                    _増減率 = 1.0 / 8.0; // １～8ダメージでも±１の変動幅を実現するために、１／８。（ＤＱ５を参考）
                    _最小ダメージ = (long)(_ダメージ中間値 * (1.0 - _増減率)); // もう一度計算
                    _最大ダメージ = (long)(_ダメージ中間値 * (1.0 + _増減率)); // もう一度計算
                }
            }
            // 受けるダメージとランダム性
            double _受けるダメージ = _ダメージ中間値;
            // 受けるダメージが0だと、正規分布は使わない（正規分布だと必ず0になってしまうから）
            if (_受けるダメージ == 0 || _増減確率分布＿trueは正規分布_falseは等確立分布 == false)
            {
                // ダメージが出る確率は1ずつ均等。最小・最大ダメージが、ダメージ中間値より出にくい、ということはない。
                _受けるダメージ = MyTools.getRandomNum((int)_最小ダメージ, (int)_最大ダメージ);
                // ダメージがintだとオーバーフローした場合、long型を使う
                if ((int)_受けるダメージ < 0)
                {
                    _受けるダメージ = MyTools.getRandomNum((long)_最小ダメージ, (long)_最大ダメージ);
                }
            }
            else
            {
                // ダメージが出る確率は正規分布に従う。最低・最大ダメージは、ダメージ中間値よりかなり出にくい。
                // 等確率の場合とバランスを取りたい場合、正規分布の場合だけ増減率を増やす（最小・最大ダメージをあげる）…ということも考えて。
                _受けるダメージ = MyTools.getSeikiRandomNum_RealWorldRate(_ダメージ中間値, _最小ダメージ, _最大ダメージ);
            }
            // ランダムで、受けるダメージがマイナスになった時は、全部0や1だと面白くないので、
            // 最大ダメージとの割合０～１００％に応じて、ダメージを0～9のひとケタにする
            if (_受けるダメージ < 0)
            {
                double _最大ダメージにおける割合_0To9 = Math.Abs(_受けるダメージ / _最大ダメージ * 10.0 - 0.1); // 0.1は10.0にならないようにする工夫
                _受けるダメージ = MyTools.getRandomNum(0, (int)_最大ダメージにおける割合_0To9);
            }
            // 最終的に返す受けるダメージは、整数で四捨五入(0.5未満でないと，ダメージが0にならないとする)
            double _整数受けるダメージ = (long)(_受けるダメージ + 0.5);

            return _整数受けるダメージ;
        }

    }
}
